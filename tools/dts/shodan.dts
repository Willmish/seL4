// DeviceTree for the Shodan SMC

/dts-v1/;

/ {
  #address-cells = <1>;
  #size-cells = <1>;
  compatible = "google,shodan0";
  model = "google,shodan0";

  chosen {
    // seL4 requires including devices that it should memory map here.
    seL4,kernel-devices =
        // TODO(mattharvey): Fix or work around an overflow of virtual
        // addresses in seL4/tools.
        //
        // It seems likely this is a bug in seL4, but I haven't yet fully
        // understood the intended design of the riscv32-specific version of
        // the seL4 page table.
        //
        // The code generation c_header.py for devices_gen.h creates physical
        // addresses at (KDEV_BASE + n * 0x400000), consistent with the 4MB
        // increments of map_kernel_frame on riscv32. While multiple devices
        // in the same 4MB physical block do get to share a frame, once they
        // aren't in the same 4MB block, we get a device with n > 1, causing
        // an overflow because KDEV_BASE is hard-coded to 0xffc00000 in the
        // riscv32 hardware.h.
        //
        // Until this is fixed, uncommenting the timer line below will generate
        // one of TIMER_PPTR or PLIC_PPTR where driver code using proper
        // offsets will step on user memory, resulting in a store/load AMO
        // exception.
        //
        // A workaround is to change the memory layout so that these two
        // peripherals lie in the same 4MB block, but the OS probably should
        // not impose that kind of constraint.

        // &{/soc/timer@40100000},
        &{/soc/interrupt-controller@41010000};
  };

  cpus {
    #address-cells = <1>;
    #size-cells = <0>;
    cpu0: cpu@0 {
      device_type = "cpu";
      reg = <0>;
      compatible = "riscv";
      riscv,isa = "rv32imac";
      mmu-type = "riscv,sv39";
      status = "okay";

      cpu0_intc: interrupt-controller {
        #interrupt-cells = <1>;
        compatible = "riscv,cpu-intc";
        interrupt-controller;
        phandle = <0x0f>;
      };
    };
  };

  memory@28000000 {
    #address-cells = <1>;
    #size-cells = <1>;
    device_type = "memory";
    // TODO(b/197745020): Change the size to 0x400000 after the system is made
    // small enough to fit.
    reg = <0x28000000 0x4000000>;
  };

  soc {
    #address-cells = <1>;
    #size-cells = <1>;
    compatible = "simple-bus";
    ranges;
    timer@40100000 {
      compatible = "lowrisc,timer";
      clock-frequency = < 24000000 >;
      reg = < 0x40100000 0x1000 >;
      interrupt-parent = <&cpu0_intc>;
      interrupts = <5>, <7>;
      interrupts-extended = <&cpu0_intc 5>, <&cpu0_intc 7>;
    };
    plic0: interrupt-controller@41010000 {
      #interrupt-cells = <1>;
      compatible = "lowrisc,plic";
      reg = <0x41010000 0x1000>;
      interrupt-controller;
      interrupt-parent = <&cpu0_intc>;
      interrupts = <9>, <11>;
      interrupts-extended = <&cpu0_intc 9>, <&cpu0_intc 11>;
      riscv,ndev = <96>;
      riscv,max-priority = <0x07>;
    };
    uart0: serial@40010000 {
      compatible = "lowrisc,uart";
      reg = <0x40010000 0x1000>;
      interrupt-parent = <&plic0>;
      interrupts = <9>, <10>, <11>, <12>, <13>, <14>, <15>, <16>;
      interrupts-extended = <&plic0 9>, <&plic0 10>, <&plic0 11>,
          <&plic0 12>, <&plic0 13>, <&plic0 14>, <&plic0 15>, <&plic0 16>;
    };
  };
};
